# 2021-05-11-Tue
날씨 짱 좋아 🤩   
이런 날에는 공부지!   
오늘은 06장 공부
## 06 프로퍼티와 초기화
자바의 필드, 코틀린의 프로퍼티
### 프로퍼티의 접근
자바의 단점?  
➡ getter/setter라는 접근 메소드를 만들어야 하는데, 
필드의 개수가 늘어나면 접근 메소드도 많아져서 코드가 어려워짐

코틀린이 **프로퍼티**라고 칭하는 이유?   
➡ 변수 선언 부분과 기본적인 접근 메소드를 모두 가지고 있기 때문
```kotlin
class Person(var name: String, var age: Int) //한줄로 접근 메소드 표현 가능
```

읽기 전용 프로퍼티(val)에는 값을 다시 지정할 수 없음   
var는 값을 다시 지정할 수 있음

#### 기본 게터와 세터 직접 지정하기
* value: 세터의 매개변수로 외부로부터 값을 가져옴
* field: 프로퍼티를 참조하는 변수 (보조 필드)
```kotlin
class User(_id: Int, _name: String, _age: Int){
    val id: Int = _id
    get() = field
    
    var name: String = _name
    get() = field
    set(value) {
        field = value
    }
    
    var age: Int = _age
    get() = field
    set(value) {
        field = value
    }
}
```
#### 커스텀 게터와 세터의 사용
* 추가적으로 getter/setter를 커스텀해서 사용을 할 수도 있다
* 프로퍼티는 오버라이딩해서 사용할 수 있음   
프로퍼티는 기본적으로 오버라이딩 할 수 없는 final 형태로 선언됨
  
```kotlin
open class First{
    open val x: Int = 0 //오버라이딩 가능
        get(){
            println("First x")
            return field
        }
    val y: Int = 0 //open 키워드가 없으면 final 프로퍼티
}
class Second: First(){
    override val x: Int = 0 //상위 클래스와 구현부가 다르게 오버라이딩
        get() {
            println("Second x")
            return field + 3
        }
    //override val y: Int = 0; 오버라이딩 불가해서 오류남
}
```
### 지연 초기화와 위임
지연 초기화를 사용하는 이유?   
➡ 객체의 정보가 나중에 나타나는 경우 객체 생성과 동시에 초기화하기 힘든 경우에 사용   
#### lateinit을 사용한 지연 초기화
기본 자료형들은 생성자에서 반드시 초기화하지만 의존성이 있는 초기화나 유닛 테스트를 위한 코드를 작성하면서 설정에 의한 초기화를 할 때는 
매번 초기화하기 불편   
> 이처럼 **특정 객체의 의존성이 있는 경우에는 지연 초기화를 해야함**
> 
클래스 선언 시 프로퍼티 선언은 null을 허용하지 않음   
➡ lateinit 키워드를 사용하면 프로퍼티에 값이 바로 할당되지 않아도 컴파일러에서 허용   
➡ 컴파일러에게 나중에 할당한다고 알려주는 것   
➡ 단 실행 시 값이 비어있는 상태면 오류를 유발할 수 있음
> **lateinit의 제한**
> * var로 선언된 프로퍼티만 가능
> * 프로퍼티에 대한 게터와 세터를 사용할 수 없음
>

객체도 지연 초기화 가능
#### lazy를 사용한 지연 초기화
읽기 전용의 val로 선언한 객체나 프로퍼티를 나중에 초기화하기 위해 사용
> **lazy 특징**
> * 호출 시점에 by lazy{...} 정의에 의해 블록 부분의 초기화 진행
> * 불변의 변수 선언인 val에서만 사용 가능(읽기 전용)
> * val이므로 값을 다시 변경 불가능
>
#### by를 이용한 위임
하나의 클래스가 다른 클래스에 위임하도록 선언하여 위임된 클래스가 가지는 멤버를 참조 없이 호출 가능   
프로퍼티 위임   
➡ 프로퍼티의 게터와 세터를 특정 객체에게 위임하고 그 객체가 값을 읽거나 쓸 때 수행하도록 만든 것

### 정적 변수와 컴패니언 객체
**정적 변수**나 **컴패니언 객체**는 동적 메모리에 할당, 해제되는 것이 아닌 
프로그램을 실행할 대 고정적으로 가지는 메모리로 객체 생성 없이 사용 가능   
#### 정적 변수와 컴패니언 객체
코틀린에서는 정적 변수 사용 시 static 키워드가 없는 대신 컴패니언 객체 제공      
컴패니언 객체는 싱글톤(Singleton)으로 정의됨
> **싱글톤(Singleton)**   
> 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 
> 생성된 객체를 어디에서든지 참조할 수 있도록 하는 디자인 패턴의 하나

## 07 다양한 클래스와 인터페이스
