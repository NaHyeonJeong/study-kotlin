# 2021-05-10-Mon
오... 삘 왔을 때 많이 공부해둬야지   

**05장 클래스와 객체**   
이 부분은 자바 공부할 때 이미 배웠던 내용이라 코틀린 연습할겸 코드만 SSG 해봐야지   
공부한 코드는 src > com > sec05 > edu 밑에 있음   
(그런데 생각보다 뭐가 많네😂)
## 상속과 다형성
### 상속과 클래스의 계층
상속해서 사용하는게 뭔가 좀 다른 것 같아서 따로 정리해봄
#### 하위 클래스 선언
```text
open class 기반_클래스_이름 {
    //묵시적으로 Any로 부터 상속됨
    //open으로 파생 가능
    ...
}
class 파생_클래스_이름 : 기반_클래스_이름(){
    //기반 클래스로부터 상속됨
    //최종 클래스로 파생 불가
}
```
### 다형성
오버로딩이랑 오버라이딩은 맨날 봐도 맨날 새롭다...ㅎㅎ
#### 오버로딩
* 동일한 클래스 안에서 같은 이름의 메소드가 매개변수만 달리해서 여러 번 정의될 수 있는 개념   
* 반환값은 동일하거나 달라질 수 있음   
* 구현되는 동작은 대부분 동일
#### 오버라이딩 (재정의)
* 하위 클래스에서 새로 만들어지는 메소드가 이름이나 매개변수, 반환값이 이전 메소드와 똑같지만 
내용이 새로 작성됨   
* 코틀린에서는 기반 클래스 내용을 파생 클래스가 오버라이딩하기 위해
기반 클래스에서는 open 키워드, 
파생 클래스에서는 override 키워드를 각각 사용   
* 코틀린에서는 메소드 뿐만 아니라 프로퍼티도 오버라이딩 할 수 있음
* 오버라이딩을 막고자 한다면 해당 메소드에 **final** 키워드 사용
## super와 this의 참조
### 바깥 클래스 호출하기
특정 클래스 안에서 선언된 클래스 = 이너 클래스   
이너 클래스에서 바깥 클래스의 상위 클래스를 호출하려면...
```kotlin
open class Base{
    open val x: Int = 1
    open fun f() = println("Base Class f()")
}

class Child: Base(){
    override val x:Int = super.x + 1
    override fun f() {
        println("Child Class f()")
    }

    inner class Inside{
        fun f() = println("Inside Class f()")
        fun test(){
            f()//inner class의 f() 사용
            Child().f()//바로 바깥 클래스의 f() 사용
            super@Child.f()//Child의 상위 클래스인 Base 클래스의 f() 사용
            println("[Inside] super@Child.x: ${super@Child.x}")//Base의 x 사용
       }
    }
}
```
![image](https://user-images.githubusercontent.com/59243409/117659310-c3248400-b1d6-11eb-8011-d72f6d4b86e6.png)
### 인터페이스에서 참조하기
코틀린은 자바처럼 한 번에 2개 이상의 클래스를 상속받는 다중 상속이 되지 않음...   
but 인터페이스는 원하는 만큼 다수의 인터페이스 지정해 구현 가능 (자바도 마찬가지)   
동일한 이름의 프로퍼티나 메소드가 있다면 **앵글 브래킷**(<>)을 사용해 접근하려는 클래스나
인터페이스의 이름을 정해줄 수 있음
```text
super<A>.f() //A클래스의 f()
super<B>.f() //B클래스의 f()
```